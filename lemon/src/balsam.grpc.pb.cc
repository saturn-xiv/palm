// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: balsam.proto

#include "balsam.pb.h"
#include "balsam.grpc.pb.h"

#include <functional>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/impl/channel_interface.h>
#include <grpcpp/impl/client_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/rpc_service_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/sync_stream.h>
namespace palm {
namespace balsam {
namespace v1 {

static const char* Aes_method_names[] = {
  "/palm.balsam.v1.Aes/Encrypt",
  "/palm.balsam.v1.Aes/Decrypt",
};

std::unique_ptr< Aes::Stub> Aes::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< Aes::Stub> stub(new Aes::Stub(channel, options));
  return stub;
}

Aes::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_Encrypt_(Aes_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Decrypt_(Aes_method_names[1], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status Aes::Stub::Encrypt(::grpc::ClientContext* context, const ::palm::balsam::v1::AesPlainMessage& request, ::palm::balsam::v1::AesCodeMessage* response) {
  return ::grpc::internal::BlockingUnaryCall< ::palm::balsam::v1::AesPlainMessage, ::palm::balsam::v1::AesCodeMessage, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_Encrypt_, context, request, response);
}

void Aes::Stub::async::Encrypt(::grpc::ClientContext* context, const ::palm::balsam::v1::AesPlainMessage* request, ::palm::balsam::v1::AesCodeMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::palm::balsam::v1::AesPlainMessage, ::palm::balsam::v1::AesCodeMessage, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Encrypt_, context, request, response, std::move(f));
}

void Aes::Stub::async::Encrypt(::grpc::ClientContext* context, const ::palm::balsam::v1::AesPlainMessage* request, ::palm::balsam::v1::AesCodeMessage* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Encrypt_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::palm::balsam::v1::AesCodeMessage>* Aes::Stub::PrepareAsyncEncryptRaw(::grpc::ClientContext* context, const ::palm::balsam::v1::AesPlainMessage& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::palm::balsam::v1::AesCodeMessage, ::palm::balsam::v1::AesPlainMessage, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Encrypt_, context, request);
}

::grpc::ClientAsyncResponseReader< ::palm::balsam::v1::AesCodeMessage>* Aes::Stub::AsyncEncryptRaw(::grpc::ClientContext* context, const ::palm::balsam::v1::AesPlainMessage& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncEncryptRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status Aes::Stub::Decrypt(::grpc::ClientContext* context, const ::palm::balsam::v1::AesCodeMessage& request, ::palm::balsam::v1::AesPlainMessage* response) {
  return ::grpc::internal::BlockingUnaryCall< ::palm::balsam::v1::AesCodeMessage, ::palm::balsam::v1::AesPlainMessage, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_Decrypt_, context, request, response);
}

void Aes::Stub::async::Decrypt(::grpc::ClientContext* context, const ::palm::balsam::v1::AesCodeMessage* request, ::palm::balsam::v1::AesPlainMessage* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::palm::balsam::v1::AesCodeMessage, ::palm::balsam::v1::AesPlainMessage, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Decrypt_, context, request, response, std::move(f));
}

void Aes::Stub::async::Decrypt(::grpc::ClientContext* context, const ::palm::balsam::v1::AesCodeMessage* request, ::palm::balsam::v1::AesPlainMessage* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Decrypt_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::palm::balsam::v1::AesPlainMessage>* Aes::Stub::PrepareAsyncDecryptRaw(::grpc::ClientContext* context, const ::palm::balsam::v1::AesCodeMessage& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::palm::balsam::v1::AesPlainMessage, ::palm::balsam::v1::AesCodeMessage, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Decrypt_, context, request);
}

::grpc::ClientAsyncResponseReader< ::palm::balsam::v1::AesPlainMessage>* Aes::Stub::AsyncDecryptRaw(::grpc::ClientContext* context, const ::palm::balsam::v1::AesCodeMessage& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncDecryptRaw(context, request, cq);
  result->StartCall();
  return result;
}

Aes::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Aes_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Aes::Service, ::palm::balsam::v1::AesPlainMessage, ::palm::balsam::v1::AesCodeMessage, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](Aes::Service* service,
             ::grpc::ServerContext* ctx,
             const ::palm::balsam::v1::AesPlainMessage* req,
             ::palm::balsam::v1::AesCodeMessage* resp) {
               return service->Encrypt(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Aes_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Aes::Service, ::palm::balsam::v1::AesCodeMessage, ::palm::balsam::v1::AesPlainMessage, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](Aes::Service* service,
             ::grpc::ServerContext* ctx,
             const ::palm::balsam::v1::AesCodeMessage* req,
             ::palm::balsam::v1::AesPlainMessage* resp) {
               return service->Decrypt(ctx, req, resp);
             }, this)));
}

Aes::Service::~Service() {
}

::grpc::Status Aes::Service::Encrypt(::grpc::ServerContext* context, const ::palm::balsam::v1::AesPlainMessage* request, ::palm::balsam::v1::AesCodeMessage* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Aes::Service::Decrypt(::grpc::ServerContext* context, const ::palm::balsam::v1::AesCodeMessage* request, ::palm::balsam::v1::AesPlainMessage* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* Jwt_method_names[] = {
  "/palm.balsam.v1.Jwt/Sign",
  "/palm.balsam.v1.Jwt/Verify",
};

std::unique_ptr< Jwt::Stub> Jwt::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< Jwt::Stub> stub(new Jwt::Stub(channel, options));
  return stub;
}

Jwt::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_Sign_(Jwt_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Verify_(Jwt_method_names[1], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status Jwt::Stub::Sign(::grpc::ClientContext* context, const ::palm::balsam::v1::JwtSignRequest& request, ::palm::balsam::v1::JwtSignResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::palm::balsam::v1::JwtSignRequest, ::palm::balsam::v1::JwtSignResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_Sign_, context, request, response);
}

void Jwt::Stub::async::Sign(::grpc::ClientContext* context, const ::palm::balsam::v1::JwtSignRequest* request, ::palm::balsam::v1::JwtSignResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::palm::balsam::v1::JwtSignRequest, ::palm::balsam::v1::JwtSignResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Sign_, context, request, response, std::move(f));
}

void Jwt::Stub::async::Sign(::grpc::ClientContext* context, const ::palm::balsam::v1::JwtSignRequest* request, ::palm::balsam::v1::JwtSignResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Sign_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::palm::balsam::v1::JwtSignResponse>* Jwt::Stub::PrepareAsyncSignRaw(::grpc::ClientContext* context, const ::palm::balsam::v1::JwtSignRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::palm::balsam::v1::JwtSignResponse, ::palm::balsam::v1::JwtSignRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Sign_, context, request);
}

::grpc::ClientAsyncResponseReader< ::palm::balsam::v1::JwtSignResponse>* Jwt::Stub::AsyncSignRaw(::grpc::ClientContext* context, const ::palm::balsam::v1::JwtSignRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncSignRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status Jwt::Stub::Verify(::grpc::ClientContext* context, const ::palm::balsam::v1::JwtVerifyRequest& request, ::palm::balsam::v1::JwtVerifyResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::palm::balsam::v1::JwtVerifyRequest, ::palm::balsam::v1::JwtVerifyResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_Verify_, context, request, response);
}

void Jwt::Stub::async::Verify(::grpc::ClientContext* context, const ::palm::balsam::v1::JwtVerifyRequest* request, ::palm::balsam::v1::JwtVerifyResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::palm::balsam::v1::JwtVerifyRequest, ::palm::balsam::v1::JwtVerifyResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Verify_, context, request, response, std::move(f));
}

void Jwt::Stub::async::Verify(::grpc::ClientContext* context, const ::palm::balsam::v1::JwtVerifyRequest* request, ::palm::balsam::v1::JwtVerifyResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Verify_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::palm::balsam::v1::JwtVerifyResponse>* Jwt::Stub::PrepareAsyncVerifyRaw(::grpc::ClientContext* context, const ::palm::balsam::v1::JwtVerifyRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::palm::balsam::v1::JwtVerifyResponse, ::palm::balsam::v1::JwtVerifyRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Verify_, context, request);
}

::grpc::ClientAsyncResponseReader< ::palm::balsam::v1::JwtVerifyResponse>* Jwt::Stub::AsyncVerifyRaw(::grpc::ClientContext* context, const ::palm::balsam::v1::JwtVerifyRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncVerifyRaw(context, request, cq);
  result->StartCall();
  return result;
}

Jwt::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Jwt_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Jwt::Service, ::palm::balsam::v1::JwtSignRequest, ::palm::balsam::v1::JwtSignResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](Jwt::Service* service,
             ::grpc::ServerContext* ctx,
             const ::palm::balsam::v1::JwtSignRequest* req,
             ::palm::balsam::v1::JwtSignResponse* resp) {
               return service->Sign(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Jwt_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Jwt::Service, ::palm::balsam::v1::JwtVerifyRequest, ::palm::balsam::v1::JwtVerifyResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](Jwt::Service* service,
             ::grpc::ServerContext* ctx,
             const ::palm::balsam::v1::JwtVerifyRequest* req,
             ::palm::balsam::v1::JwtVerifyResponse* resp) {
               return service->Verify(ctx, req, resp);
             }, this)));
}

Jwt::Service::~Service() {
}

::grpc::Status Jwt::Service::Sign(::grpc::ServerContext* context, const ::palm::balsam::v1::JwtSignRequest* request, ::palm::balsam::v1::JwtSignResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Jwt::Service::Verify(::grpc::ServerContext* context, const ::palm::balsam::v1::JwtVerifyRequest* request, ::palm::balsam::v1::JwtVerifyResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* HMac_method_names[] = {
  "/palm.balsam.v1.HMac/Sign",
  "/palm.balsam.v1.HMac/Verify",
};

std::unique_ptr< HMac::Stub> HMac::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< HMac::Stub> stub(new HMac::Stub(channel, options));
  return stub;
}

HMac::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_Sign_(HMac_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Verify_(HMac_method_names[1], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status HMac::Stub::Sign(::grpc::ClientContext* context, const ::palm::balsam::v1::HMacSignRequest& request, ::palm::balsam::v1::HMacSignResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::palm::balsam::v1::HMacSignRequest, ::palm::balsam::v1::HMacSignResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_Sign_, context, request, response);
}

void HMac::Stub::async::Sign(::grpc::ClientContext* context, const ::palm::balsam::v1::HMacSignRequest* request, ::palm::balsam::v1::HMacSignResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::palm::balsam::v1::HMacSignRequest, ::palm::balsam::v1::HMacSignResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Sign_, context, request, response, std::move(f));
}

void HMac::Stub::async::Sign(::grpc::ClientContext* context, const ::palm::balsam::v1::HMacSignRequest* request, ::palm::balsam::v1::HMacSignResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Sign_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::palm::balsam::v1::HMacSignResponse>* HMac::Stub::PrepareAsyncSignRaw(::grpc::ClientContext* context, const ::palm::balsam::v1::HMacSignRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::palm::balsam::v1::HMacSignResponse, ::palm::balsam::v1::HMacSignRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Sign_, context, request);
}

::grpc::ClientAsyncResponseReader< ::palm::balsam::v1::HMacSignResponse>* HMac::Stub::AsyncSignRaw(::grpc::ClientContext* context, const ::palm::balsam::v1::HMacSignRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncSignRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status HMac::Stub::Verify(::grpc::ClientContext* context, const ::palm::balsam::v1::HMacVerifyRequest& request, ::google::protobuf::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall< ::palm::balsam::v1::HMacVerifyRequest, ::google::protobuf::Empty, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_Verify_, context, request, response);
}

void HMac::Stub::async::Verify(::grpc::ClientContext* context, const ::palm::balsam::v1::HMacVerifyRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::palm::balsam::v1::HMacVerifyRequest, ::google::protobuf::Empty, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Verify_, context, request, response, std::move(f));
}

void HMac::Stub::async::Verify(::grpc::ClientContext* context, const ::palm::balsam::v1::HMacVerifyRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Verify_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* HMac::Stub::PrepareAsyncVerifyRaw(::grpc::ClientContext* context, const ::palm::balsam::v1::HMacVerifyRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::google::protobuf::Empty, ::palm::balsam::v1::HMacVerifyRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Verify_, context, request);
}

::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* HMac::Stub::AsyncVerifyRaw(::grpc::ClientContext* context, const ::palm::balsam::v1::HMacVerifyRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncVerifyRaw(context, request, cq);
  result->StartCall();
  return result;
}

HMac::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      HMac_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< HMac::Service, ::palm::balsam::v1::HMacSignRequest, ::palm::balsam::v1::HMacSignResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](HMac::Service* service,
             ::grpc::ServerContext* ctx,
             const ::palm::balsam::v1::HMacSignRequest* req,
             ::palm::balsam::v1::HMacSignResponse* resp) {
               return service->Sign(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      HMac_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< HMac::Service, ::palm::balsam::v1::HMacVerifyRequest, ::google::protobuf::Empty, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](HMac::Service* service,
             ::grpc::ServerContext* ctx,
             const ::palm::balsam::v1::HMacVerifyRequest* req,
             ::google::protobuf::Empty* resp) {
               return service->Verify(ctx, req, resp);
             }, this)));
}

HMac::Service::~Service() {
}

::grpc::Status HMac::Service::Sign(::grpc::ServerContext* context, const ::palm::balsam::v1::HMacSignRequest* request, ::palm::balsam::v1::HMacSignResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status HMac::Service::Verify(::grpc::ServerContext* context, const ::palm::balsam::v1::HMacVerifyRequest* request, ::google::protobuf::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* User_method_names[] = {
  "/palm.balsam.v1.User/SignInByEmail",
};

std::unique_ptr< User::Stub> User::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< User::Stub> stub(new User::Stub(channel, options));
  return stub;
}

User::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_SignInByEmail_(User_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status User::Stub::SignInByEmail(::grpc::ClientContext* context, const ::palm::balsam::v1::UserSignInByEmail& request, ::palm::balsam::v1::UserSignInResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::palm::balsam::v1::UserSignInByEmail, ::palm::balsam::v1::UserSignInResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_SignInByEmail_, context, request, response);
}

void User::Stub::async::SignInByEmail(::grpc::ClientContext* context, const ::palm::balsam::v1::UserSignInByEmail* request, ::palm::balsam::v1::UserSignInResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::palm::balsam::v1::UserSignInByEmail, ::palm::balsam::v1::UserSignInResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SignInByEmail_, context, request, response, std::move(f));
}

void User::Stub::async::SignInByEmail(::grpc::ClientContext* context, const ::palm::balsam::v1::UserSignInByEmail* request, ::palm::balsam::v1::UserSignInResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SignInByEmail_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::palm::balsam::v1::UserSignInResponse>* User::Stub::PrepareAsyncSignInByEmailRaw(::grpc::ClientContext* context, const ::palm::balsam::v1::UserSignInByEmail& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::palm::balsam::v1::UserSignInResponse, ::palm::balsam::v1::UserSignInByEmail, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_SignInByEmail_, context, request);
}

::grpc::ClientAsyncResponseReader< ::palm::balsam::v1::UserSignInResponse>* User::Stub::AsyncSignInByEmailRaw(::grpc::ClientContext* context, const ::palm::balsam::v1::UserSignInByEmail& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncSignInByEmailRaw(context, request, cq);
  result->StartCall();
  return result;
}

User::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      User_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< User::Service, ::palm::balsam::v1::UserSignInByEmail, ::palm::balsam::v1::UserSignInResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](User::Service* service,
             ::grpc::ServerContext* ctx,
             const ::palm::balsam::v1::UserSignInByEmail* req,
             ::palm::balsam::v1::UserSignInResponse* resp) {
               return service->SignInByEmail(ctx, req, resp);
             }, this)));
}

User::Service::~Service() {
}

::grpc::Status User::Service::SignInByEmail(::grpc::ServerContext* context, const ::palm::balsam::v1::UserSignInByEmail* request, ::palm::balsam::v1::UserSignInResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


}  // namespace palm
}  // namespace balsam
}  // namespace v1

