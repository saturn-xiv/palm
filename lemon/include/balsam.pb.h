// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: balsam.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_balsam_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_balsam_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
#include <google/protobuf/duration.pb.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_balsam_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_balsam_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_balsam_2eproto;
namespace palm {
namespace balsam {
namespace v1 {
class AesCodeMessage;
struct AesCodeMessageDefaultTypeInternal;
extern AesCodeMessageDefaultTypeInternal _AesCodeMessage_default_instance_;
class AesPlainMessage;
struct AesPlainMessageDefaultTypeInternal;
extern AesPlainMessageDefaultTypeInternal _AesPlainMessage_default_instance_;
class HMacSignRequest;
struct HMacSignRequestDefaultTypeInternal;
extern HMacSignRequestDefaultTypeInternal _HMacSignRequest_default_instance_;
class HMacSignResponse;
struct HMacSignResponseDefaultTypeInternal;
extern HMacSignResponseDefaultTypeInternal _HMacSignResponse_default_instance_;
class HMacVerifyRequest;
struct HMacVerifyRequestDefaultTypeInternal;
extern HMacVerifyRequestDefaultTypeInternal _HMacVerifyRequest_default_instance_;
class JwtSignRequest;
struct JwtSignRequestDefaultTypeInternal;
extern JwtSignRequestDefaultTypeInternal _JwtSignRequest_default_instance_;
class JwtSignResponse;
struct JwtSignResponseDefaultTypeInternal;
extern JwtSignResponseDefaultTypeInternal _JwtSignResponse_default_instance_;
class JwtVerifyRequest;
struct JwtVerifyRequestDefaultTypeInternal;
extern JwtVerifyRequestDefaultTypeInternal _JwtVerifyRequest_default_instance_;
class JwtVerifyResponse;
struct JwtVerifyResponseDefaultTypeInternal;
extern JwtVerifyResponseDefaultTypeInternal _JwtVerifyResponse_default_instance_;
class UserSignInByEmail;
struct UserSignInByEmailDefaultTypeInternal;
extern UserSignInByEmailDefaultTypeInternal _UserSignInByEmail_default_instance_;
class UserSignInResponse;
struct UserSignInResponseDefaultTypeInternal;
extern UserSignInResponseDefaultTypeInternal _UserSignInResponse_default_instance_;
}  // namespace v1
}  // namespace balsam
}  // namespace palm
PROTOBUF_NAMESPACE_OPEN
template<> ::palm::balsam::v1::AesCodeMessage* Arena::CreateMaybeMessage<::palm::balsam::v1::AesCodeMessage>(Arena*);
template<> ::palm::balsam::v1::AesPlainMessage* Arena::CreateMaybeMessage<::palm::balsam::v1::AesPlainMessage>(Arena*);
template<> ::palm::balsam::v1::HMacSignRequest* Arena::CreateMaybeMessage<::palm::balsam::v1::HMacSignRequest>(Arena*);
template<> ::palm::balsam::v1::HMacSignResponse* Arena::CreateMaybeMessage<::palm::balsam::v1::HMacSignResponse>(Arena*);
template<> ::palm::balsam::v1::HMacVerifyRequest* Arena::CreateMaybeMessage<::palm::balsam::v1::HMacVerifyRequest>(Arena*);
template<> ::palm::balsam::v1::JwtSignRequest* Arena::CreateMaybeMessage<::palm::balsam::v1::JwtSignRequest>(Arena*);
template<> ::palm::balsam::v1::JwtSignResponse* Arena::CreateMaybeMessage<::palm::balsam::v1::JwtSignResponse>(Arena*);
template<> ::palm::balsam::v1::JwtVerifyRequest* Arena::CreateMaybeMessage<::palm::balsam::v1::JwtVerifyRequest>(Arena*);
template<> ::palm::balsam::v1::JwtVerifyResponse* Arena::CreateMaybeMessage<::palm::balsam::v1::JwtVerifyResponse>(Arena*);
template<> ::palm::balsam::v1::UserSignInByEmail* Arena::CreateMaybeMessage<::palm::balsam::v1::UserSignInByEmail>(Arena*);
template<> ::palm::balsam::v1::UserSignInResponse* Arena::CreateMaybeMessage<::palm::balsam::v1::UserSignInResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace palm {
namespace balsam {
namespace v1 {

// ===================================================================

class AesPlainMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.balsam.v1.AesPlainMessage) */ {
 public:
  inline AesPlainMessage() : AesPlainMessage(nullptr) {}
  ~AesPlainMessage() override;
  explicit PROTOBUF_CONSTEXPR AesPlainMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AesPlainMessage(const AesPlainMessage& from);
  AesPlainMessage(AesPlainMessage&& from) noexcept
    : AesPlainMessage() {
    *this = ::std::move(from);
  }

  inline AesPlainMessage& operator=(const AesPlainMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AesPlainMessage& operator=(AesPlainMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AesPlainMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AesPlainMessage* internal_default_instance() {
    return reinterpret_cast<const AesPlainMessage*>(
               &_AesPlainMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AesPlainMessage& a, AesPlainMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AesPlainMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AesPlainMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AesPlainMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AesPlainMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AesPlainMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AesPlainMessage& from) {
    AesPlainMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AesPlainMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.balsam.v1.AesPlainMessage";
  }
  protected:
  explicit AesPlainMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 1,
  };
  // bytes payload = 1;
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // @@protoc_insertion_point(class_scope:palm.balsam.v1.AesPlainMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_balsam_2eproto;
};
// -------------------------------------------------------------------

class AesCodeMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.balsam.v1.AesCodeMessage) */ {
 public:
  inline AesCodeMessage() : AesCodeMessage(nullptr) {}
  ~AesCodeMessage() override;
  explicit PROTOBUF_CONSTEXPR AesCodeMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AesCodeMessage(const AesCodeMessage& from);
  AesCodeMessage(AesCodeMessage&& from) noexcept
    : AesCodeMessage() {
    *this = ::std::move(from);
  }

  inline AesCodeMessage& operator=(const AesCodeMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AesCodeMessage& operator=(AesCodeMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AesCodeMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AesCodeMessage* internal_default_instance() {
    return reinterpret_cast<const AesCodeMessage*>(
               &_AesCodeMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AesCodeMessage& a, AesCodeMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AesCodeMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AesCodeMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AesCodeMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AesCodeMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AesCodeMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AesCodeMessage& from) {
    AesCodeMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AesCodeMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.balsam.v1.AesCodeMessage";
  }
  protected:
  explicit AesCodeMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 1,
    kSaltFieldNumber = 2,
  };
  // bytes payload = 1;
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // bytes salt = 2;
  void clear_salt();
  const std::string& salt() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_salt(ArgT0&& arg0, ArgT... args);
  std::string* mutable_salt();
  PROTOBUF_NODISCARD std::string* release_salt();
  void set_allocated_salt(std::string* salt);
  private:
  const std::string& _internal_salt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_salt(const std::string& value);
  std::string* _internal_mutable_salt();
  public:

  // @@protoc_insertion_point(class_scope:palm.balsam.v1.AesCodeMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr salt_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_balsam_2eproto;
};
// -------------------------------------------------------------------

class JwtSignRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.balsam.v1.JwtSignRequest) */ {
 public:
  inline JwtSignRequest() : JwtSignRequest(nullptr) {}
  ~JwtSignRequest() override;
  explicit PROTOBUF_CONSTEXPR JwtSignRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JwtSignRequest(const JwtSignRequest& from);
  JwtSignRequest(JwtSignRequest&& from) noexcept
    : JwtSignRequest() {
    *this = ::std::move(from);
  }

  inline JwtSignRequest& operator=(const JwtSignRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline JwtSignRequest& operator=(JwtSignRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JwtSignRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const JwtSignRequest* internal_default_instance() {
    return reinterpret_cast<const JwtSignRequest*>(
               &_JwtSignRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(JwtSignRequest& a, JwtSignRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(JwtSignRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JwtSignRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JwtSignRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JwtSignRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JwtSignRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JwtSignRequest& from) {
    JwtSignRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JwtSignRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.balsam.v1.JwtSignRequest";
  }
  protected:
  explicit JwtSignRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudiencesFieldNumber = 13,
    kKeyIdFieldNumber = 1,
    kIssuerFieldNumber = 11,
    kSubjectFieldNumber = 12,
    kExtraFieldNumber = 99,
    kNotBeforeFieldNumber = 18,
    kExpiresAtFieldNumber = 19,
  };
  // repeated string audiences = 13;
  int audiences_size() const;
  private:
  int _internal_audiences_size() const;
  public:
  void clear_audiences();
  const std::string& audiences(int index) const;
  std::string* mutable_audiences(int index);
  void set_audiences(int index, const std::string& value);
  void set_audiences(int index, std::string&& value);
  void set_audiences(int index, const char* value);
  void set_audiences(int index, const char* value, size_t size);
  std::string* add_audiences();
  void add_audiences(const std::string& value);
  void add_audiences(std::string&& value);
  void add_audiences(const char* value);
  void add_audiences(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& audiences() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_audiences();
  private:
  const std::string& _internal_audiences(int index) const;
  std::string* _internal_add_audiences();
  public:

  // optional string key_id = 1;
  bool has_key_id() const;
  private:
  bool _internal_has_key_id() const;
  public:
  void clear_key_id();
  const std::string& key_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key_id();
  PROTOBUF_NODISCARD std::string* release_key_id();
  void set_allocated_key_id(std::string* key_id);
  private:
  const std::string& _internal_key_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key_id(const std::string& value);
  std::string* _internal_mutable_key_id();
  public:

  // string issuer = 11;
  void clear_issuer();
  const std::string& issuer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_issuer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_issuer();
  PROTOBUF_NODISCARD std::string* release_issuer();
  void set_allocated_issuer(std::string* issuer);
  private:
  const std::string& _internal_issuer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_issuer(const std::string& value);
  std::string* _internal_mutable_issuer();
  public:

  // string subject = 12;
  void clear_subject();
  const std::string& subject() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subject(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subject();
  PROTOBUF_NODISCARD std::string* release_subject();
  void set_allocated_subject(std::string* subject);
  private:
  const std::string& _internal_subject() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subject(const std::string& value);
  std::string* _internal_mutable_subject();
  public:

  // optional string extra = 99;
  bool has_extra() const;
  private:
  bool _internal_has_extra() const;
  public:
  void clear_extra();
  const std::string& extra() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_extra(ArgT0&& arg0, ArgT... args);
  std::string* mutable_extra();
  PROTOBUF_NODISCARD std::string* release_extra();
  void set_allocated_extra(std::string* extra);
  private:
  const std::string& _internal_extra() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extra(const std::string& value);
  std::string* _internal_mutable_extra();
  public:

  // .google.protobuf.Timestamp not_before = 18;
  bool has_not_before() const;
  private:
  bool _internal_has_not_before() const;
  public:
  void clear_not_before();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& not_before() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_not_before();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_not_before();
  void set_allocated_not_before(::PROTOBUF_NAMESPACE_ID::Timestamp* not_before);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_not_before() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_not_before();
  public:
  void unsafe_arena_set_allocated_not_before(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* not_before);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_not_before();

  // .google.protobuf.Timestamp expires_at = 19;
  bool has_expires_at() const;
  private:
  bool _internal_has_expires_at() const;
  public:
  void clear_expires_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& expires_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_expires_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_expires_at();
  void set_allocated_expires_at(::PROTOBUF_NAMESPACE_ID::Timestamp* expires_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_expires_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_expires_at();
  public:
  void unsafe_arena_set_allocated_expires_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* expires_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_expires_at();

  // @@protoc_insertion_point(class_scope:palm.balsam.v1.JwtSignRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> audiences_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr issuer_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subject_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extra_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* not_before_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* expires_at_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_balsam_2eproto;
};
// -------------------------------------------------------------------

class JwtSignResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.balsam.v1.JwtSignResponse) */ {
 public:
  inline JwtSignResponse() : JwtSignResponse(nullptr) {}
  ~JwtSignResponse() override;
  explicit PROTOBUF_CONSTEXPR JwtSignResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JwtSignResponse(const JwtSignResponse& from);
  JwtSignResponse(JwtSignResponse&& from) noexcept
    : JwtSignResponse() {
    *this = ::std::move(from);
  }

  inline JwtSignResponse& operator=(const JwtSignResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline JwtSignResponse& operator=(JwtSignResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JwtSignResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const JwtSignResponse* internal_default_instance() {
    return reinterpret_cast<const JwtSignResponse*>(
               &_JwtSignResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(JwtSignResponse& a, JwtSignResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(JwtSignResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JwtSignResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JwtSignResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JwtSignResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JwtSignResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JwtSignResponse& from) {
    JwtSignResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JwtSignResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.balsam.v1.JwtSignResponse";
  }
  protected:
  explicit JwtSignResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
  };
  // string token = 1;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // @@protoc_insertion_point(class_scope:palm.balsam.v1.JwtSignResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_balsam_2eproto;
};
// -------------------------------------------------------------------

class JwtVerifyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.balsam.v1.JwtVerifyRequest) */ {
 public:
  inline JwtVerifyRequest() : JwtVerifyRequest(nullptr) {}
  ~JwtVerifyRequest() override;
  explicit PROTOBUF_CONSTEXPR JwtVerifyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JwtVerifyRequest(const JwtVerifyRequest& from);
  JwtVerifyRequest(JwtVerifyRequest&& from) noexcept
    : JwtVerifyRequest() {
    *this = ::std::move(from);
  }

  inline JwtVerifyRequest& operator=(const JwtVerifyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline JwtVerifyRequest& operator=(JwtVerifyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JwtVerifyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const JwtVerifyRequest* internal_default_instance() {
    return reinterpret_cast<const JwtVerifyRequest*>(
               &_JwtVerifyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(JwtVerifyRequest& a, JwtVerifyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(JwtVerifyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JwtVerifyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JwtVerifyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JwtVerifyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JwtVerifyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JwtVerifyRequest& from) {
    JwtVerifyRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JwtVerifyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.balsam.v1.JwtVerifyRequest";
  }
  protected:
  explicit JwtVerifyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
    kIssuerFieldNumber = 2,
    kAudienceFieldNumber = 3,
  };
  // string token = 1;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // string issuer = 2;
  void clear_issuer();
  const std::string& issuer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_issuer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_issuer();
  PROTOBUF_NODISCARD std::string* release_issuer();
  void set_allocated_issuer(std::string* issuer);
  private:
  const std::string& _internal_issuer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_issuer(const std::string& value);
  std::string* _internal_mutable_issuer();
  public:

  // string audience = 3;
  void clear_audience();
  const std::string& audience() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_audience(ArgT0&& arg0, ArgT... args);
  std::string* mutable_audience();
  PROTOBUF_NODISCARD std::string* release_audience();
  void set_allocated_audience(std::string* audience);
  private:
  const std::string& _internal_audience() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audience(const std::string& value);
  std::string* _internal_mutable_audience();
  public:

  // @@protoc_insertion_point(class_scope:palm.balsam.v1.JwtVerifyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr issuer_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audience_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_balsam_2eproto;
};
// -------------------------------------------------------------------

class JwtVerifyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.balsam.v1.JwtVerifyResponse) */ {
 public:
  inline JwtVerifyResponse() : JwtVerifyResponse(nullptr) {}
  ~JwtVerifyResponse() override;
  explicit PROTOBUF_CONSTEXPR JwtVerifyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JwtVerifyResponse(const JwtVerifyResponse& from);
  JwtVerifyResponse(JwtVerifyResponse&& from) noexcept
    : JwtVerifyResponse() {
    *this = ::std::move(from);
  }

  inline JwtVerifyResponse& operator=(const JwtVerifyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline JwtVerifyResponse& operator=(JwtVerifyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JwtVerifyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const JwtVerifyResponse* internal_default_instance() {
    return reinterpret_cast<const JwtVerifyResponse*>(
               &_JwtVerifyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(JwtVerifyResponse& a, JwtVerifyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(JwtVerifyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JwtVerifyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JwtVerifyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JwtVerifyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JwtVerifyResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JwtVerifyResponse& from) {
    JwtVerifyResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JwtVerifyResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.balsam.v1.JwtVerifyResponse";
  }
  protected:
  explicit JwtVerifyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJwtIdFieldNumber = 1,
    kKeyIdFieldNumber = 2,
    kSubjectFieldNumber = 11,
    kExtraFieldNumber = 19,
  };
  // string jwt_id = 1;
  void clear_jwt_id();
  const std::string& jwt_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_jwt_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_jwt_id();
  PROTOBUF_NODISCARD std::string* release_jwt_id();
  void set_allocated_jwt_id(std::string* jwt_id);
  private:
  const std::string& _internal_jwt_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_jwt_id(const std::string& value);
  std::string* _internal_mutable_jwt_id();
  public:

  // optional string key_id = 2;
  bool has_key_id() const;
  private:
  bool _internal_has_key_id() const;
  public:
  void clear_key_id();
  const std::string& key_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key_id();
  PROTOBUF_NODISCARD std::string* release_key_id();
  void set_allocated_key_id(std::string* key_id);
  private:
  const std::string& _internal_key_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key_id(const std::string& value);
  std::string* _internal_mutable_key_id();
  public:

  // string subject = 11;
  void clear_subject();
  const std::string& subject() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subject(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subject();
  PROTOBUF_NODISCARD std::string* release_subject();
  void set_allocated_subject(std::string* subject);
  private:
  const std::string& _internal_subject() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subject(const std::string& value);
  std::string* _internal_mutable_subject();
  public:

  // optional string extra = 19;
  bool has_extra() const;
  private:
  bool _internal_has_extra() const;
  public:
  void clear_extra();
  const std::string& extra() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_extra(ArgT0&& arg0, ArgT... args);
  std::string* mutable_extra();
  PROTOBUF_NODISCARD std::string* release_extra();
  void set_allocated_extra(std::string* extra);
  private:
  const std::string& _internal_extra() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extra(const std::string& value);
  std::string* _internal_mutable_extra();
  public:

  // @@protoc_insertion_point(class_scope:palm.balsam.v1.JwtVerifyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr jwt_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subject_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extra_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_balsam_2eproto;
};
// -------------------------------------------------------------------

class HMacSignRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.balsam.v1.HMacSignRequest) */ {
 public:
  inline HMacSignRequest() : HMacSignRequest(nullptr) {}
  ~HMacSignRequest() override;
  explicit PROTOBUF_CONSTEXPR HMacSignRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HMacSignRequest(const HMacSignRequest& from);
  HMacSignRequest(HMacSignRequest&& from) noexcept
    : HMacSignRequest() {
    *this = ::std::move(from);
  }

  inline HMacSignRequest& operator=(const HMacSignRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HMacSignRequest& operator=(HMacSignRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HMacSignRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HMacSignRequest* internal_default_instance() {
    return reinterpret_cast<const HMacSignRequest*>(
               &_HMacSignRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(HMacSignRequest& a, HMacSignRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HMacSignRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HMacSignRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HMacSignRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HMacSignRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HMacSignRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HMacSignRequest& from) {
    HMacSignRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HMacSignRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.balsam.v1.HMacSignRequest";
  }
  protected:
  explicit HMacSignRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlainFieldNumber = 1,
  };
  // bytes plain = 1;
  void clear_plain();
  const std::string& plain() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_plain(ArgT0&& arg0, ArgT... args);
  std::string* mutable_plain();
  PROTOBUF_NODISCARD std::string* release_plain();
  void set_allocated_plain(std::string* plain);
  private:
  const std::string& _internal_plain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_plain(const std::string& value);
  std::string* _internal_mutable_plain();
  public:

  // @@protoc_insertion_point(class_scope:palm.balsam.v1.HMacSignRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr plain_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_balsam_2eproto;
};
// -------------------------------------------------------------------

class HMacSignResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.balsam.v1.HMacSignResponse) */ {
 public:
  inline HMacSignResponse() : HMacSignResponse(nullptr) {}
  ~HMacSignResponse() override;
  explicit PROTOBUF_CONSTEXPR HMacSignResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HMacSignResponse(const HMacSignResponse& from);
  HMacSignResponse(HMacSignResponse&& from) noexcept
    : HMacSignResponse() {
    *this = ::std::move(from);
  }

  inline HMacSignResponse& operator=(const HMacSignResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HMacSignResponse& operator=(HMacSignResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HMacSignResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HMacSignResponse* internal_default_instance() {
    return reinterpret_cast<const HMacSignResponse*>(
               &_HMacSignResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(HMacSignResponse& a, HMacSignResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HMacSignResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HMacSignResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HMacSignResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HMacSignResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HMacSignResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HMacSignResponse& from) {
    HMacSignResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HMacSignResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.balsam.v1.HMacSignResponse";
  }
  protected:
  explicit HMacSignResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCodeFieldNumber = 1,
  };
  // bytes code = 1;
  void clear_code();
  const std::string& code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_code();
  PROTOBUF_NODISCARD std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // @@protoc_insertion_point(class_scope:palm.balsam.v1.HMacSignResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_balsam_2eproto;
};
// -------------------------------------------------------------------

class HMacVerifyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.balsam.v1.HMacVerifyRequest) */ {
 public:
  inline HMacVerifyRequest() : HMacVerifyRequest(nullptr) {}
  ~HMacVerifyRequest() override;
  explicit PROTOBUF_CONSTEXPR HMacVerifyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HMacVerifyRequest(const HMacVerifyRequest& from);
  HMacVerifyRequest(HMacVerifyRequest&& from) noexcept
    : HMacVerifyRequest() {
    *this = ::std::move(from);
  }

  inline HMacVerifyRequest& operator=(const HMacVerifyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HMacVerifyRequest& operator=(HMacVerifyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HMacVerifyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HMacVerifyRequest* internal_default_instance() {
    return reinterpret_cast<const HMacVerifyRequest*>(
               &_HMacVerifyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(HMacVerifyRequest& a, HMacVerifyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HMacVerifyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HMacVerifyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HMacVerifyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HMacVerifyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HMacVerifyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HMacVerifyRequest& from) {
    HMacVerifyRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HMacVerifyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.balsam.v1.HMacVerifyRequest";
  }
  protected:
  explicit HMacVerifyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlainFieldNumber = 1,
    kCodeFieldNumber = 2,
  };
  // bytes plain = 1;
  void clear_plain();
  const std::string& plain() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_plain(ArgT0&& arg0, ArgT... args);
  std::string* mutable_plain();
  PROTOBUF_NODISCARD std::string* release_plain();
  void set_allocated_plain(std::string* plain);
  private:
  const std::string& _internal_plain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_plain(const std::string& value);
  std::string* _internal_mutable_plain();
  public:

  // bytes code = 2;
  void clear_code();
  const std::string& code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_code();
  PROTOBUF_NODISCARD std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // @@protoc_insertion_point(class_scope:palm.balsam.v1.HMacVerifyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr plain_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_balsam_2eproto;
};
// -------------------------------------------------------------------

class UserSignInByEmail final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.balsam.v1.UserSignInByEmail) */ {
 public:
  inline UserSignInByEmail() : UserSignInByEmail(nullptr) {}
  ~UserSignInByEmail() override;
  explicit PROTOBUF_CONSTEXPR UserSignInByEmail(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserSignInByEmail(const UserSignInByEmail& from);
  UserSignInByEmail(UserSignInByEmail&& from) noexcept
    : UserSignInByEmail() {
    *this = ::std::move(from);
  }

  inline UserSignInByEmail& operator=(const UserSignInByEmail& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserSignInByEmail& operator=(UserSignInByEmail&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserSignInByEmail& default_instance() {
    return *internal_default_instance();
  }
  enum UserCase {
    kEmail = 1,
    kNickname = 2,
    USER_NOT_SET = 0,
  };

  static inline const UserSignInByEmail* internal_default_instance() {
    return reinterpret_cast<const UserSignInByEmail*>(
               &_UserSignInByEmail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(UserSignInByEmail& a, UserSignInByEmail& b) {
    a.Swap(&b);
  }
  inline void Swap(UserSignInByEmail* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserSignInByEmail* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserSignInByEmail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserSignInByEmail>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserSignInByEmail& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserSignInByEmail& from) {
    UserSignInByEmail::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserSignInByEmail* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.balsam.v1.UserSignInByEmail";
  }
  protected:
  explicit UserSignInByEmail(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPasswordFieldNumber = 8,
    kTtlFieldNumber = 9,
    kEmailFieldNumber = 1,
    kNicknameFieldNumber = 2,
  };
  // string password = 8;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // .google.protobuf.Duration ttl = 9;
  bool has_ttl() const;
  private:
  bool _internal_has_ttl() const;
  public:
  void clear_ttl();
  const ::PROTOBUF_NAMESPACE_ID::Duration& ttl() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_ttl();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_ttl();
  void set_allocated_ttl(::PROTOBUF_NAMESPACE_ID::Duration* ttl);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_ttl() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_ttl();
  public:
  void unsafe_arena_set_allocated_ttl(
      ::PROTOBUF_NAMESPACE_ID::Duration* ttl);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_ttl();

  // string email = 1;
  bool has_email() const;
  private:
  bool _internal_has_email() const;
  public:
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // string nickname = 2;
  bool has_nickname() const;
  private:
  bool _internal_has_nickname() const;
  public:
  void clear_nickname();
  const std::string& nickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* nickname);
  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(const std::string& value);
  std::string* _internal_mutable_nickname();
  public:

  void clear_user();
  UserCase user_case() const;
  // @@protoc_insertion_point(class_scope:palm.balsam.v1.UserSignInByEmail)
 private:
  class _Internal;
  void set_has_email();
  void set_has_nickname();

  inline bool has_user() const;
  inline void clear_has_user();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    ::PROTOBUF_NAMESPACE_ID::Duration* ttl_;
    union UserUnion {
      constexpr UserUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nickname_;
    } user_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_balsam_2eproto;
};
// -------------------------------------------------------------------

class UserSignInResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:palm.balsam.v1.UserSignInResponse) */ {
 public:
  inline UserSignInResponse() : UserSignInResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR UserSignInResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserSignInResponse(const UserSignInResponse& from);
  UserSignInResponse(UserSignInResponse&& from) noexcept
    : UserSignInResponse() {
    *this = ::std::move(from);
  }

  inline UserSignInResponse& operator=(const UserSignInResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserSignInResponse& operator=(UserSignInResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserSignInResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserSignInResponse* internal_default_instance() {
    return reinterpret_cast<const UserSignInResponse*>(
               &_UserSignInResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(UserSignInResponse& a, UserSignInResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UserSignInResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserSignInResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserSignInResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserSignInResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UserSignInResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UserSignInResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.balsam.v1.UserSignInResponse";
  }
  protected:
  explicit UserSignInResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:palm.balsam.v1.UserSignInResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_balsam_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AesPlainMessage

// bytes payload = 1;
inline void AesPlainMessage::clear_payload() {
  _impl_.payload_.ClearToEmpty();
}
inline const std::string& AesPlainMessage::payload() const {
  // @@protoc_insertion_point(field_get:palm.balsam.v1.AesPlainMessage.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AesPlainMessage::set_payload(ArgT0&& arg0, ArgT... args) {
 
 _impl_.payload_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.balsam.v1.AesPlainMessage.payload)
}
inline std::string* AesPlainMessage::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:palm.balsam.v1.AesPlainMessage.payload)
  return _s;
}
inline const std::string& AesPlainMessage::_internal_payload() const {
  return _impl_.payload_.Get();
}
inline void AesPlainMessage::_internal_set_payload(const std::string& value) {
  
  _impl_.payload_.Set(value, GetArenaForAllocation());
}
inline std::string* AesPlainMessage::_internal_mutable_payload() {
  
  return _impl_.payload_.Mutable(GetArenaForAllocation());
}
inline std::string* AesPlainMessage::release_payload() {
  // @@protoc_insertion_point(field_release:palm.balsam.v1.AesPlainMessage.payload)
  return _impl_.payload_.Release();
}
inline void AesPlainMessage::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  _impl_.payload_.SetAllocated(payload, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.payload_.IsDefault()) {
    _impl_.payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.balsam.v1.AesPlainMessage.payload)
}

// -------------------------------------------------------------------

// AesCodeMessage

// bytes payload = 1;
inline void AesCodeMessage::clear_payload() {
  _impl_.payload_.ClearToEmpty();
}
inline const std::string& AesCodeMessage::payload() const {
  // @@protoc_insertion_point(field_get:palm.balsam.v1.AesCodeMessage.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AesCodeMessage::set_payload(ArgT0&& arg0, ArgT... args) {
 
 _impl_.payload_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.balsam.v1.AesCodeMessage.payload)
}
inline std::string* AesCodeMessage::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:palm.balsam.v1.AesCodeMessage.payload)
  return _s;
}
inline const std::string& AesCodeMessage::_internal_payload() const {
  return _impl_.payload_.Get();
}
inline void AesCodeMessage::_internal_set_payload(const std::string& value) {
  
  _impl_.payload_.Set(value, GetArenaForAllocation());
}
inline std::string* AesCodeMessage::_internal_mutable_payload() {
  
  return _impl_.payload_.Mutable(GetArenaForAllocation());
}
inline std::string* AesCodeMessage::release_payload() {
  // @@protoc_insertion_point(field_release:palm.balsam.v1.AesCodeMessage.payload)
  return _impl_.payload_.Release();
}
inline void AesCodeMessage::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  _impl_.payload_.SetAllocated(payload, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.payload_.IsDefault()) {
    _impl_.payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.balsam.v1.AesCodeMessage.payload)
}

// bytes salt = 2;
inline void AesCodeMessage::clear_salt() {
  _impl_.salt_.ClearToEmpty();
}
inline const std::string& AesCodeMessage::salt() const {
  // @@protoc_insertion_point(field_get:palm.balsam.v1.AesCodeMessage.salt)
  return _internal_salt();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AesCodeMessage::set_salt(ArgT0&& arg0, ArgT... args) {
 
 _impl_.salt_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.balsam.v1.AesCodeMessage.salt)
}
inline std::string* AesCodeMessage::mutable_salt() {
  std::string* _s = _internal_mutable_salt();
  // @@protoc_insertion_point(field_mutable:palm.balsam.v1.AesCodeMessage.salt)
  return _s;
}
inline const std::string& AesCodeMessage::_internal_salt() const {
  return _impl_.salt_.Get();
}
inline void AesCodeMessage::_internal_set_salt(const std::string& value) {
  
  _impl_.salt_.Set(value, GetArenaForAllocation());
}
inline std::string* AesCodeMessage::_internal_mutable_salt() {
  
  return _impl_.salt_.Mutable(GetArenaForAllocation());
}
inline std::string* AesCodeMessage::release_salt() {
  // @@protoc_insertion_point(field_release:palm.balsam.v1.AesCodeMessage.salt)
  return _impl_.salt_.Release();
}
inline void AesCodeMessage::set_allocated_salt(std::string* salt) {
  if (salt != nullptr) {
    
  } else {
    
  }
  _impl_.salt_.SetAllocated(salt, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.salt_.IsDefault()) {
    _impl_.salt_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.balsam.v1.AesCodeMessage.salt)
}

// -------------------------------------------------------------------

// JwtSignRequest

// optional string key_id = 1;
inline bool JwtSignRequest::_internal_has_key_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool JwtSignRequest::has_key_id() const {
  return _internal_has_key_id();
}
inline void JwtSignRequest::clear_key_id() {
  _impl_.key_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& JwtSignRequest::key_id() const {
  // @@protoc_insertion_point(field_get:palm.balsam.v1.JwtSignRequest.key_id)
  return _internal_key_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JwtSignRequest::set_key_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.key_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.balsam.v1.JwtSignRequest.key_id)
}
inline std::string* JwtSignRequest::mutable_key_id() {
  std::string* _s = _internal_mutable_key_id();
  // @@protoc_insertion_point(field_mutable:palm.balsam.v1.JwtSignRequest.key_id)
  return _s;
}
inline const std::string& JwtSignRequest::_internal_key_id() const {
  return _impl_.key_id_.Get();
}
inline void JwtSignRequest::_internal_set_key_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.key_id_.Set(value, GetArenaForAllocation());
}
inline std::string* JwtSignRequest::_internal_mutable_key_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.key_id_.Mutable(GetArenaForAllocation());
}
inline std::string* JwtSignRequest::release_key_id() {
  // @@protoc_insertion_point(field_release:palm.balsam.v1.JwtSignRequest.key_id)
  if (!_internal_has_key_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.key_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_id_.IsDefault()) {
    _impl_.key_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void JwtSignRequest::set_allocated_key_id(std::string* key_id) {
  if (key_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.key_id_.SetAllocated(key_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_id_.IsDefault()) {
    _impl_.key_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.balsam.v1.JwtSignRequest.key_id)
}

// string issuer = 11;
inline void JwtSignRequest::clear_issuer() {
  _impl_.issuer_.ClearToEmpty();
}
inline const std::string& JwtSignRequest::issuer() const {
  // @@protoc_insertion_point(field_get:palm.balsam.v1.JwtSignRequest.issuer)
  return _internal_issuer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JwtSignRequest::set_issuer(ArgT0&& arg0, ArgT... args) {
 
 _impl_.issuer_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.balsam.v1.JwtSignRequest.issuer)
}
inline std::string* JwtSignRequest::mutable_issuer() {
  std::string* _s = _internal_mutable_issuer();
  // @@protoc_insertion_point(field_mutable:palm.balsam.v1.JwtSignRequest.issuer)
  return _s;
}
inline const std::string& JwtSignRequest::_internal_issuer() const {
  return _impl_.issuer_.Get();
}
inline void JwtSignRequest::_internal_set_issuer(const std::string& value) {
  
  _impl_.issuer_.Set(value, GetArenaForAllocation());
}
inline std::string* JwtSignRequest::_internal_mutable_issuer() {
  
  return _impl_.issuer_.Mutable(GetArenaForAllocation());
}
inline std::string* JwtSignRequest::release_issuer() {
  // @@protoc_insertion_point(field_release:palm.balsam.v1.JwtSignRequest.issuer)
  return _impl_.issuer_.Release();
}
inline void JwtSignRequest::set_allocated_issuer(std::string* issuer) {
  if (issuer != nullptr) {
    
  } else {
    
  }
  _impl_.issuer_.SetAllocated(issuer, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.issuer_.IsDefault()) {
    _impl_.issuer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.balsam.v1.JwtSignRequest.issuer)
}

// string subject = 12;
inline void JwtSignRequest::clear_subject() {
  _impl_.subject_.ClearToEmpty();
}
inline const std::string& JwtSignRequest::subject() const {
  // @@protoc_insertion_point(field_get:palm.balsam.v1.JwtSignRequest.subject)
  return _internal_subject();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JwtSignRequest::set_subject(ArgT0&& arg0, ArgT... args) {
 
 _impl_.subject_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.balsam.v1.JwtSignRequest.subject)
}
inline std::string* JwtSignRequest::mutable_subject() {
  std::string* _s = _internal_mutable_subject();
  // @@protoc_insertion_point(field_mutable:palm.balsam.v1.JwtSignRequest.subject)
  return _s;
}
inline const std::string& JwtSignRequest::_internal_subject() const {
  return _impl_.subject_.Get();
}
inline void JwtSignRequest::_internal_set_subject(const std::string& value) {
  
  _impl_.subject_.Set(value, GetArenaForAllocation());
}
inline std::string* JwtSignRequest::_internal_mutable_subject() {
  
  return _impl_.subject_.Mutable(GetArenaForAllocation());
}
inline std::string* JwtSignRequest::release_subject() {
  // @@protoc_insertion_point(field_release:palm.balsam.v1.JwtSignRequest.subject)
  return _impl_.subject_.Release();
}
inline void JwtSignRequest::set_allocated_subject(std::string* subject) {
  if (subject != nullptr) {
    
  } else {
    
  }
  _impl_.subject_.SetAllocated(subject, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.subject_.IsDefault()) {
    _impl_.subject_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.balsam.v1.JwtSignRequest.subject)
}

// repeated string audiences = 13;
inline int JwtSignRequest::_internal_audiences_size() const {
  return _impl_.audiences_.size();
}
inline int JwtSignRequest::audiences_size() const {
  return _internal_audiences_size();
}
inline void JwtSignRequest::clear_audiences() {
  _impl_.audiences_.Clear();
}
inline std::string* JwtSignRequest::add_audiences() {
  std::string* _s = _internal_add_audiences();
  // @@protoc_insertion_point(field_add_mutable:palm.balsam.v1.JwtSignRequest.audiences)
  return _s;
}
inline const std::string& JwtSignRequest::_internal_audiences(int index) const {
  return _impl_.audiences_.Get(index);
}
inline const std::string& JwtSignRequest::audiences(int index) const {
  // @@protoc_insertion_point(field_get:palm.balsam.v1.JwtSignRequest.audiences)
  return _internal_audiences(index);
}
inline std::string* JwtSignRequest::mutable_audiences(int index) {
  // @@protoc_insertion_point(field_mutable:palm.balsam.v1.JwtSignRequest.audiences)
  return _impl_.audiences_.Mutable(index);
}
inline void JwtSignRequest::set_audiences(int index, const std::string& value) {
  _impl_.audiences_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:palm.balsam.v1.JwtSignRequest.audiences)
}
inline void JwtSignRequest::set_audiences(int index, std::string&& value) {
  _impl_.audiences_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:palm.balsam.v1.JwtSignRequest.audiences)
}
inline void JwtSignRequest::set_audiences(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.audiences_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:palm.balsam.v1.JwtSignRequest.audiences)
}
inline void JwtSignRequest::set_audiences(int index, const char* value, size_t size) {
  _impl_.audiences_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:palm.balsam.v1.JwtSignRequest.audiences)
}
inline std::string* JwtSignRequest::_internal_add_audiences() {
  return _impl_.audiences_.Add();
}
inline void JwtSignRequest::add_audiences(const std::string& value) {
  _impl_.audiences_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:palm.balsam.v1.JwtSignRequest.audiences)
}
inline void JwtSignRequest::add_audiences(std::string&& value) {
  _impl_.audiences_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:palm.balsam.v1.JwtSignRequest.audiences)
}
inline void JwtSignRequest::add_audiences(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.audiences_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:palm.balsam.v1.JwtSignRequest.audiences)
}
inline void JwtSignRequest::add_audiences(const char* value, size_t size) {
  _impl_.audiences_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:palm.balsam.v1.JwtSignRequest.audiences)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
JwtSignRequest::audiences() const {
  // @@protoc_insertion_point(field_list:palm.balsam.v1.JwtSignRequest.audiences)
  return _impl_.audiences_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
JwtSignRequest::mutable_audiences() {
  // @@protoc_insertion_point(field_mutable_list:palm.balsam.v1.JwtSignRequest.audiences)
  return &_impl_.audiences_;
}

// .google.protobuf.Timestamp not_before = 18;
inline bool JwtSignRequest::_internal_has_not_before() const {
  return this != internal_default_instance() && _impl_.not_before_ != nullptr;
}
inline bool JwtSignRequest::has_not_before() const {
  return _internal_has_not_before();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& JwtSignRequest::_internal_not_before() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.not_before_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& JwtSignRequest::not_before() const {
  // @@protoc_insertion_point(field_get:palm.balsam.v1.JwtSignRequest.not_before)
  return _internal_not_before();
}
inline void JwtSignRequest::unsafe_arena_set_allocated_not_before(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* not_before) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.not_before_);
  }
  _impl_.not_before_ = not_before;
  if (not_before) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.balsam.v1.JwtSignRequest.not_before)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* JwtSignRequest::release_not_before() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.not_before_;
  _impl_.not_before_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* JwtSignRequest::unsafe_arena_release_not_before() {
  // @@protoc_insertion_point(field_release:palm.balsam.v1.JwtSignRequest.not_before)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.not_before_;
  _impl_.not_before_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* JwtSignRequest::_internal_mutable_not_before() {
  
  if (_impl_.not_before_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.not_before_ = p;
  }
  return _impl_.not_before_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* JwtSignRequest::mutable_not_before() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_not_before();
  // @@protoc_insertion_point(field_mutable:palm.balsam.v1.JwtSignRequest.not_before)
  return _msg;
}
inline void JwtSignRequest::set_allocated_not_before(::PROTOBUF_NAMESPACE_ID::Timestamp* not_before) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.not_before_);
  }
  if (not_before) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(not_before));
    if (message_arena != submessage_arena) {
      not_before = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, not_before, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.not_before_ = not_before;
  // @@protoc_insertion_point(field_set_allocated:palm.balsam.v1.JwtSignRequest.not_before)
}

// .google.protobuf.Timestamp expires_at = 19;
inline bool JwtSignRequest::_internal_has_expires_at() const {
  return this != internal_default_instance() && _impl_.expires_at_ != nullptr;
}
inline bool JwtSignRequest::has_expires_at() const {
  return _internal_has_expires_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& JwtSignRequest::_internal_expires_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.expires_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& JwtSignRequest::expires_at() const {
  // @@protoc_insertion_point(field_get:palm.balsam.v1.JwtSignRequest.expires_at)
  return _internal_expires_at();
}
inline void JwtSignRequest::unsafe_arena_set_allocated_expires_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* expires_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expires_at_);
  }
  _impl_.expires_at_ = expires_at;
  if (expires_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.balsam.v1.JwtSignRequest.expires_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* JwtSignRequest::release_expires_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.expires_at_;
  _impl_.expires_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* JwtSignRequest::unsafe_arena_release_expires_at() {
  // @@protoc_insertion_point(field_release:palm.balsam.v1.JwtSignRequest.expires_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.expires_at_;
  _impl_.expires_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* JwtSignRequest::_internal_mutable_expires_at() {
  
  if (_impl_.expires_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.expires_at_ = p;
  }
  return _impl_.expires_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* JwtSignRequest::mutable_expires_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_expires_at();
  // @@protoc_insertion_point(field_mutable:palm.balsam.v1.JwtSignRequest.expires_at)
  return _msg;
}
inline void JwtSignRequest::set_allocated_expires_at(::PROTOBUF_NAMESPACE_ID::Timestamp* expires_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expires_at_);
  }
  if (expires_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expires_at));
    if (message_arena != submessage_arena) {
      expires_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expires_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.expires_at_ = expires_at;
  // @@protoc_insertion_point(field_set_allocated:palm.balsam.v1.JwtSignRequest.expires_at)
}

// optional string extra = 99;
inline bool JwtSignRequest::_internal_has_extra() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool JwtSignRequest::has_extra() const {
  return _internal_has_extra();
}
inline void JwtSignRequest::clear_extra() {
  _impl_.extra_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& JwtSignRequest::extra() const {
  // @@protoc_insertion_point(field_get:palm.balsam.v1.JwtSignRequest.extra)
  return _internal_extra();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JwtSignRequest::set_extra(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.extra_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.balsam.v1.JwtSignRequest.extra)
}
inline std::string* JwtSignRequest::mutable_extra() {
  std::string* _s = _internal_mutable_extra();
  // @@protoc_insertion_point(field_mutable:palm.balsam.v1.JwtSignRequest.extra)
  return _s;
}
inline const std::string& JwtSignRequest::_internal_extra() const {
  return _impl_.extra_.Get();
}
inline void JwtSignRequest::_internal_set_extra(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.extra_.Set(value, GetArenaForAllocation());
}
inline std::string* JwtSignRequest::_internal_mutable_extra() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.extra_.Mutable(GetArenaForAllocation());
}
inline std::string* JwtSignRequest::release_extra() {
  // @@protoc_insertion_point(field_release:palm.balsam.v1.JwtSignRequest.extra)
  if (!_internal_has_extra()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.extra_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.extra_.IsDefault()) {
    _impl_.extra_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void JwtSignRequest::set_allocated_extra(std::string* extra) {
  if (extra != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.extra_.SetAllocated(extra, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.extra_.IsDefault()) {
    _impl_.extra_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.balsam.v1.JwtSignRequest.extra)
}

// -------------------------------------------------------------------

// JwtSignResponse

// string token = 1;
inline void JwtSignResponse::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& JwtSignResponse::token() const {
  // @@protoc_insertion_point(field_get:palm.balsam.v1.JwtSignResponse.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JwtSignResponse::set_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.balsam.v1.JwtSignResponse.token)
}
inline std::string* JwtSignResponse::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:palm.balsam.v1.JwtSignResponse.token)
  return _s;
}
inline const std::string& JwtSignResponse::_internal_token() const {
  return _impl_.token_.Get();
}
inline void JwtSignResponse::_internal_set_token(const std::string& value) {
  
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* JwtSignResponse::_internal_mutable_token() {
  
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* JwtSignResponse::release_token() {
  // @@protoc_insertion_point(field_release:palm.balsam.v1.JwtSignResponse.token)
  return _impl_.token_.Release();
}
inline void JwtSignResponse::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.balsam.v1.JwtSignResponse.token)
}

// -------------------------------------------------------------------

// JwtVerifyRequest

// string token = 1;
inline void JwtVerifyRequest::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& JwtVerifyRequest::token() const {
  // @@protoc_insertion_point(field_get:palm.balsam.v1.JwtVerifyRequest.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JwtVerifyRequest::set_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.balsam.v1.JwtVerifyRequest.token)
}
inline std::string* JwtVerifyRequest::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:palm.balsam.v1.JwtVerifyRequest.token)
  return _s;
}
inline const std::string& JwtVerifyRequest::_internal_token() const {
  return _impl_.token_.Get();
}
inline void JwtVerifyRequest::_internal_set_token(const std::string& value) {
  
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* JwtVerifyRequest::_internal_mutable_token() {
  
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* JwtVerifyRequest::release_token() {
  // @@protoc_insertion_point(field_release:palm.balsam.v1.JwtVerifyRequest.token)
  return _impl_.token_.Release();
}
inline void JwtVerifyRequest::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.balsam.v1.JwtVerifyRequest.token)
}

// string issuer = 2;
inline void JwtVerifyRequest::clear_issuer() {
  _impl_.issuer_.ClearToEmpty();
}
inline const std::string& JwtVerifyRequest::issuer() const {
  // @@protoc_insertion_point(field_get:palm.balsam.v1.JwtVerifyRequest.issuer)
  return _internal_issuer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JwtVerifyRequest::set_issuer(ArgT0&& arg0, ArgT... args) {
 
 _impl_.issuer_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.balsam.v1.JwtVerifyRequest.issuer)
}
inline std::string* JwtVerifyRequest::mutable_issuer() {
  std::string* _s = _internal_mutable_issuer();
  // @@protoc_insertion_point(field_mutable:palm.balsam.v1.JwtVerifyRequest.issuer)
  return _s;
}
inline const std::string& JwtVerifyRequest::_internal_issuer() const {
  return _impl_.issuer_.Get();
}
inline void JwtVerifyRequest::_internal_set_issuer(const std::string& value) {
  
  _impl_.issuer_.Set(value, GetArenaForAllocation());
}
inline std::string* JwtVerifyRequest::_internal_mutable_issuer() {
  
  return _impl_.issuer_.Mutable(GetArenaForAllocation());
}
inline std::string* JwtVerifyRequest::release_issuer() {
  // @@protoc_insertion_point(field_release:palm.balsam.v1.JwtVerifyRequest.issuer)
  return _impl_.issuer_.Release();
}
inline void JwtVerifyRequest::set_allocated_issuer(std::string* issuer) {
  if (issuer != nullptr) {
    
  } else {
    
  }
  _impl_.issuer_.SetAllocated(issuer, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.issuer_.IsDefault()) {
    _impl_.issuer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.balsam.v1.JwtVerifyRequest.issuer)
}

// string audience = 3;
inline void JwtVerifyRequest::clear_audience() {
  _impl_.audience_.ClearToEmpty();
}
inline const std::string& JwtVerifyRequest::audience() const {
  // @@protoc_insertion_point(field_get:palm.balsam.v1.JwtVerifyRequest.audience)
  return _internal_audience();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JwtVerifyRequest::set_audience(ArgT0&& arg0, ArgT... args) {
 
 _impl_.audience_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.balsam.v1.JwtVerifyRequest.audience)
}
inline std::string* JwtVerifyRequest::mutable_audience() {
  std::string* _s = _internal_mutable_audience();
  // @@protoc_insertion_point(field_mutable:palm.balsam.v1.JwtVerifyRequest.audience)
  return _s;
}
inline const std::string& JwtVerifyRequest::_internal_audience() const {
  return _impl_.audience_.Get();
}
inline void JwtVerifyRequest::_internal_set_audience(const std::string& value) {
  
  _impl_.audience_.Set(value, GetArenaForAllocation());
}
inline std::string* JwtVerifyRequest::_internal_mutable_audience() {
  
  return _impl_.audience_.Mutable(GetArenaForAllocation());
}
inline std::string* JwtVerifyRequest::release_audience() {
  // @@protoc_insertion_point(field_release:palm.balsam.v1.JwtVerifyRequest.audience)
  return _impl_.audience_.Release();
}
inline void JwtVerifyRequest::set_allocated_audience(std::string* audience) {
  if (audience != nullptr) {
    
  } else {
    
  }
  _impl_.audience_.SetAllocated(audience, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.audience_.IsDefault()) {
    _impl_.audience_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.balsam.v1.JwtVerifyRequest.audience)
}

// -------------------------------------------------------------------

// JwtVerifyResponse

// string jwt_id = 1;
inline void JwtVerifyResponse::clear_jwt_id() {
  _impl_.jwt_id_.ClearToEmpty();
}
inline const std::string& JwtVerifyResponse::jwt_id() const {
  // @@protoc_insertion_point(field_get:palm.balsam.v1.JwtVerifyResponse.jwt_id)
  return _internal_jwt_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JwtVerifyResponse::set_jwt_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.jwt_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.balsam.v1.JwtVerifyResponse.jwt_id)
}
inline std::string* JwtVerifyResponse::mutable_jwt_id() {
  std::string* _s = _internal_mutable_jwt_id();
  // @@protoc_insertion_point(field_mutable:palm.balsam.v1.JwtVerifyResponse.jwt_id)
  return _s;
}
inline const std::string& JwtVerifyResponse::_internal_jwt_id() const {
  return _impl_.jwt_id_.Get();
}
inline void JwtVerifyResponse::_internal_set_jwt_id(const std::string& value) {
  
  _impl_.jwt_id_.Set(value, GetArenaForAllocation());
}
inline std::string* JwtVerifyResponse::_internal_mutable_jwt_id() {
  
  return _impl_.jwt_id_.Mutable(GetArenaForAllocation());
}
inline std::string* JwtVerifyResponse::release_jwt_id() {
  // @@protoc_insertion_point(field_release:palm.balsam.v1.JwtVerifyResponse.jwt_id)
  return _impl_.jwt_id_.Release();
}
inline void JwtVerifyResponse::set_allocated_jwt_id(std::string* jwt_id) {
  if (jwt_id != nullptr) {
    
  } else {
    
  }
  _impl_.jwt_id_.SetAllocated(jwt_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.jwt_id_.IsDefault()) {
    _impl_.jwt_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.balsam.v1.JwtVerifyResponse.jwt_id)
}

// optional string key_id = 2;
inline bool JwtVerifyResponse::_internal_has_key_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool JwtVerifyResponse::has_key_id() const {
  return _internal_has_key_id();
}
inline void JwtVerifyResponse::clear_key_id() {
  _impl_.key_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& JwtVerifyResponse::key_id() const {
  // @@protoc_insertion_point(field_get:palm.balsam.v1.JwtVerifyResponse.key_id)
  return _internal_key_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JwtVerifyResponse::set_key_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.key_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.balsam.v1.JwtVerifyResponse.key_id)
}
inline std::string* JwtVerifyResponse::mutable_key_id() {
  std::string* _s = _internal_mutable_key_id();
  // @@protoc_insertion_point(field_mutable:palm.balsam.v1.JwtVerifyResponse.key_id)
  return _s;
}
inline const std::string& JwtVerifyResponse::_internal_key_id() const {
  return _impl_.key_id_.Get();
}
inline void JwtVerifyResponse::_internal_set_key_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.key_id_.Set(value, GetArenaForAllocation());
}
inline std::string* JwtVerifyResponse::_internal_mutable_key_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.key_id_.Mutable(GetArenaForAllocation());
}
inline std::string* JwtVerifyResponse::release_key_id() {
  // @@protoc_insertion_point(field_release:palm.balsam.v1.JwtVerifyResponse.key_id)
  if (!_internal_has_key_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.key_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_id_.IsDefault()) {
    _impl_.key_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void JwtVerifyResponse::set_allocated_key_id(std::string* key_id) {
  if (key_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.key_id_.SetAllocated(key_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_id_.IsDefault()) {
    _impl_.key_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.balsam.v1.JwtVerifyResponse.key_id)
}

// string subject = 11;
inline void JwtVerifyResponse::clear_subject() {
  _impl_.subject_.ClearToEmpty();
}
inline const std::string& JwtVerifyResponse::subject() const {
  // @@protoc_insertion_point(field_get:palm.balsam.v1.JwtVerifyResponse.subject)
  return _internal_subject();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JwtVerifyResponse::set_subject(ArgT0&& arg0, ArgT... args) {
 
 _impl_.subject_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.balsam.v1.JwtVerifyResponse.subject)
}
inline std::string* JwtVerifyResponse::mutable_subject() {
  std::string* _s = _internal_mutable_subject();
  // @@protoc_insertion_point(field_mutable:palm.balsam.v1.JwtVerifyResponse.subject)
  return _s;
}
inline const std::string& JwtVerifyResponse::_internal_subject() const {
  return _impl_.subject_.Get();
}
inline void JwtVerifyResponse::_internal_set_subject(const std::string& value) {
  
  _impl_.subject_.Set(value, GetArenaForAllocation());
}
inline std::string* JwtVerifyResponse::_internal_mutable_subject() {
  
  return _impl_.subject_.Mutable(GetArenaForAllocation());
}
inline std::string* JwtVerifyResponse::release_subject() {
  // @@protoc_insertion_point(field_release:palm.balsam.v1.JwtVerifyResponse.subject)
  return _impl_.subject_.Release();
}
inline void JwtVerifyResponse::set_allocated_subject(std::string* subject) {
  if (subject != nullptr) {
    
  } else {
    
  }
  _impl_.subject_.SetAllocated(subject, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.subject_.IsDefault()) {
    _impl_.subject_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.balsam.v1.JwtVerifyResponse.subject)
}

// optional string extra = 19;
inline bool JwtVerifyResponse::_internal_has_extra() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool JwtVerifyResponse::has_extra() const {
  return _internal_has_extra();
}
inline void JwtVerifyResponse::clear_extra() {
  _impl_.extra_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& JwtVerifyResponse::extra() const {
  // @@protoc_insertion_point(field_get:palm.balsam.v1.JwtVerifyResponse.extra)
  return _internal_extra();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JwtVerifyResponse::set_extra(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.extra_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.balsam.v1.JwtVerifyResponse.extra)
}
inline std::string* JwtVerifyResponse::mutable_extra() {
  std::string* _s = _internal_mutable_extra();
  // @@protoc_insertion_point(field_mutable:palm.balsam.v1.JwtVerifyResponse.extra)
  return _s;
}
inline const std::string& JwtVerifyResponse::_internal_extra() const {
  return _impl_.extra_.Get();
}
inline void JwtVerifyResponse::_internal_set_extra(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.extra_.Set(value, GetArenaForAllocation());
}
inline std::string* JwtVerifyResponse::_internal_mutable_extra() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.extra_.Mutable(GetArenaForAllocation());
}
inline std::string* JwtVerifyResponse::release_extra() {
  // @@protoc_insertion_point(field_release:palm.balsam.v1.JwtVerifyResponse.extra)
  if (!_internal_has_extra()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.extra_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.extra_.IsDefault()) {
    _impl_.extra_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void JwtVerifyResponse::set_allocated_extra(std::string* extra) {
  if (extra != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.extra_.SetAllocated(extra, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.extra_.IsDefault()) {
    _impl_.extra_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.balsam.v1.JwtVerifyResponse.extra)
}

// -------------------------------------------------------------------

// HMacSignRequest

// bytes plain = 1;
inline void HMacSignRequest::clear_plain() {
  _impl_.plain_.ClearToEmpty();
}
inline const std::string& HMacSignRequest::plain() const {
  // @@protoc_insertion_point(field_get:palm.balsam.v1.HMacSignRequest.plain)
  return _internal_plain();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HMacSignRequest::set_plain(ArgT0&& arg0, ArgT... args) {
 
 _impl_.plain_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.balsam.v1.HMacSignRequest.plain)
}
inline std::string* HMacSignRequest::mutable_plain() {
  std::string* _s = _internal_mutable_plain();
  // @@protoc_insertion_point(field_mutable:palm.balsam.v1.HMacSignRequest.plain)
  return _s;
}
inline const std::string& HMacSignRequest::_internal_plain() const {
  return _impl_.plain_.Get();
}
inline void HMacSignRequest::_internal_set_plain(const std::string& value) {
  
  _impl_.plain_.Set(value, GetArenaForAllocation());
}
inline std::string* HMacSignRequest::_internal_mutable_plain() {
  
  return _impl_.plain_.Mutable(GetArenaForAllocation());
}
inline std::string* HMacSignRequest::release_plain() {
  // @@protoc_insertion_point(field_release:palm.balsam.v1.HMacSignRequest.plain)
  return _impl_.plain_.Release();
}
inline void HMacSignRequest::set_allocated_plain(std::string* plain) {
  if (plain != nullptr) {
    
  } else {
    
  }
  _impl_.plain_.SetAllocated(plain, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.plain_.IsDefault()) {
    _impl_.plain_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.balsam.v1.HMacSignRequest.plain)
}

// -------------------------------------------------------------------

// HMacSignResponse

// bytes code = 1;
inline void HMacSignResponse::clear_code() {
  _impl_.code_.ClearToEmpty();
}
inline const std::string& HMacSignResponse::code() const {
  // @@protoc_insertion_point(field_get:palm.balsam.v1.HMacSignResponse.code)
  return _internal_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HMacSignResponse::set_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.code_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.balsam.v1.HMacSignResponse.code)
}
inline std::string* HMacSignResponse::mutable_code() {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:palm.balsam.v1.HMacSignResponse.code)
  return _s;
}
inline const std::string& HMacSignResponse::_internal_code() const {
  return _impl_.code_.Get();
}
inline void HMacSignResponse::_internal_set_code(const std::string& value) {
  
  _impl_.code_.Set(value, GetArenaForAllocation());
}
inline std::string* HMacSignResponse::_internal_mutable_code() {
  
  return _impl_.code_.Mutable(GetArenaForAllocation());
}
inline std::string* HMacSignResponse::release_code() {
  // @@protoc_insertion_point(field_release:palm.balsam.v1.HMacSignResponse.code)
  return _impl_.code_.Release();
}
inline void HMacSignResponse::set_allocated_code(std::string* code) {
  if (code != nullptr) {
    
  } else {
    
  }
  _impl_.code_.SetAllocated(code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.code_.IsDefault()) {
    _impl_.code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.balsam.v1.HMacSignResponse.code)
}

// -------------------------------------------------------------------

// HMacVerifyRequest

// bytes plain = 1;
inline void HMacVerifyRequest::clear_plain() {
  _impl_.plain_.ClearToEmpty();
}
inline const std::string& HMacVerifyRequest::plain() const {
  // @@protoc_insertion_point(field_get:palm.balsam.v1.HMacVerifyRequest.plain)
  return _internal_plain();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HMacVerifyRequest::set_plain(ArgT0&& arg0, ArgT... args) {
 
 _impl_.plain_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.balsam.v1.HMacVerifyRequest.plain)
}
inline std::string* HMacVerifyRequest::mutable_plain() {
  std::string* _s = _internal_mutable_plain();
  // @@protoc_insertion_point(field_mutable:palm.balsam.v1.HMacVerifyRequest.plain)
  return _s;
}
inline const std::string& HMacVerifyRequest::_internal_plain() const {
  return _impl_.plain_.Get();
}
inline void HMacVerifyRequest::_internal_set_plain(const std::string& value) {
  
  _impl_.plain_.Set(value, GetArenaForAllocation());
}
inline std::string* HMacVerifyRequest::_internal_mutable_plain() {
  
  return _impl_.plain_.Mutable(GetArenaForAllocation());
}
inline std::string* HMacVerifyRequest::release_plain() {
  // @@protoc_insertion_point(field_release:palm.balsam.v1.HMacVerifyRequest.plain)
  return _impl_.plain_.Release();
}
inline void HMacVerifyRequest::set_allocated_plain(std::string* plain) {
  if (plain != nullptr) {
    
  } else {
    
  }
  _impl_.plain_.SetAllocated(plain, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.plain_.IsDefault()) {
    _impl_.plain_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.balsam.v1.HMacVerifyRequest.plain)
}

// bytes code = 2;
inline void HMacVerifyRequest::clear_code() {
  _impl_.code_.ClearToEmpty();
}
inline const std::string& HMacVerifyRequest::code() const {
  // @@protoc_insertion_point(field_get:palm.balsam.v1.HMacVerifyRequest.code)
  return _internal_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HMacVerifyRequest::set_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.code_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.balsam.v1.HMacVerifyRequest.code)
}
inline std::string* HMacVerifyRequest::mutable_code() {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:palm.balsam.v1.HMacVerifyRequest.code)
  return _s;
}
inline const std::string& HMacVerifyRequest::_internal_code() const {
  return _impl_.code_.Get();
}
inline void HMacVerifyRequest::_internal_set_code(const std::string& value) {
  
  _impl_.code_.Set(value, GetArenaForAllocation());
}
inline std::string* HMacVerifyRequest::_internal_mutable_code() {
  
  return _impl_.code_.Mutable(GetArenaForAllocation());
}
inline std::string* HMacVerifyRequest::release_code() {
  // @@protoc_insertion_point(field_release:palm.balsam.v1.HMacVerifyRequest.code)
  return _impl_.code_.Release();
}
inline void HMacVerifyRequest::set_allocated_code(std::string* code) {
  if (code != nullptr) {
    
  } else {
    
  }
  _impl_.code_.SetAllocated(code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.code_.IsDefault()) {
    _impl_.code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.balsam.v1.HMacVerifyRequest.code)
}

// -------------------------------------------------------------------

// UserSignInByEmail

// string email = 1;
inline bool UserSignInByEmail::_internal_has_email() const {
  return user_case() == kEmail;
}
inline bool UserSignInByEmail::has_email() const {
  return _internal_has_email();
}
inline void UserSignInByEmail::set_has_email() {
  _impl_._oneof_case_[0] = kEmail;
}
inline void UserSignInByEmail::clear_email() {
  if (_internal_has_email()) {
    _impl_.user_.email_.Destroy();
    clear_has_user();
  }
}
inline const std::string& UserSignInByEmail::email() const {
  // @@protoc_insertion_point(field_get:palm.balsam.v1.UserSignInByEmail.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline void UserSignInByEmail::set_email(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_email()) {
    clear_user();
    set_has_email();
    _impl_.user_.email_.InitDefault();
  }
  _impl_.user_.email_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.balsam.v1.UserSignInByEmail.email)
}
inline std::string* UserSignInByEmail::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:palm.balsam.v1.UserSignInByEmail.email)
  return _s;
}
inline const std::string& UserSignInByEmail::_internal_email() const {
  if (_internal_has_email()) {
    return _impl_.user_.email_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void UserSignInByEmail::_internal_set_email(const std::string& value) {
  if (!_internal_has_email()) {
    clear_user();
    set_has_email();
    _impl_.user_.email_.InitDefault();
  }
  _impl_.user_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSignInByEmail::_internal_mutable_email() {
  if (!_internal_has_email()) {
    clear_user();
    set_has_email();
    _impl_.user_.email_.InitDefault();
  }
  return _impl_.user_.email_.Mutable(      GetArenaForAllocation());
}
inline std::string* UserSignInByEmail::release_email() {
  // @@protoc_insertion_point(field_release:palm.balsam.v1.UserSignInByEmail.email)
  if (_internal_has_email()) {
    clear_has_user();
    return _impl_.user_.email_.Release();
  } else {
    return nullptr;
  }
}
inline void UserSignInByEmail::set_allocated_email(std::string* email) {
  if (has_user()) {
    clear_user();
  }
  if (email != nullptr) {
    set_has_email();
    _impl_.user_.email_.InitAllocated(email, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:palm.balsam.v1.UserSignInByEmail.email)
}

// string nickname = 2;
inline bool UserSignInByEmail::_internal_has_nickname() const {
  return user_case() == kNickname;
}
inline bool UserSignInByEmail::has_nickname() const {
  return _internal_has_nickname();
}
inline void UserSignInByEmail::set_has_nickname() {
  _impl_._oneof_case_[0] = kNickname;
}
inline void UserSignInByEmail::clear_nickname() {
  if (_internal_has_nickname()) {
    _impl_.user_.nickname_.Destroy();
    clear_has_user();
  }
}
inline const std::string& UserSignInByEmail::nickname() const {
  // @@protoc_insertion_point(field_get:palm.balsam.v1.UserSignInByEmail.nickname)
  return _internal_nickname();
}
template <typename ArgT0, typename... ArgT>
inline void UserSignInByEmail::set_nickname(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_nickname()) {
    clear_user();
    set_has_nickname();
    _impl_.user_.nickname_.InitDefault();
  }
  _impl_.user_.nickname_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.balsam.v1.UserSignInByEmail.nickname)
}
inline std::string* UserSignInByEmail::mutable_nickname() {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:palm.balsam.v1.UserSignInByEmail.nickname)
  return _s;
}
inline const std::string& UserSignInByEmail::_internal_nickname() const {
  if (_internal_has_nickname()) {
    return _impl_.user_.nickname_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void UserSignInByEmail::_internal_set_nickname(const std::string& value) {
  if (!_internal_has_nickname()) {
    clear_user();
    set_has_nickname();
    _impl_.user_.nickname_.InitDefault();
  }
  _impl_.user_.nickname_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSignInByEmail::_internal_mutable_nickname() {
  if (!_internal_has_nickname()) {
    clear_user();
    set_has_nickname();
    _impl_.user_.nickname_.InitDefault();
  }
  return _impl_.user_.nickname_.Mutable(      GetArenaForAllocation());
}
inline std::string* UserSignInByEmail::release_nickname() {
  // @@protoc_insertion_point(field_release:palm.balsam.v1.UserSignInByEmail.nickname)
  if (_internal_has_nickname()) {
    clear_has_user();
    return _impl_.user_.nickname_.Release();
  } else {
    return nullptr;
  }
}
inline void UserSignInByEmail::set_allocated_nickname(std::string* nickname) {
  if (has_user()) {
    clear_user();
  }
  if (nickname != nullptr) {
    set_has_nickname();
    _impl_.user_.nickname_.InitAllocated(nickname, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:palm.balsam.v1.UserSignInByEmail.nickname)
}

// string password = 8;
inline void UserSignInByEmail::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& UserSignInByEmail::password() const {
  // @@protoc_insertion_point(field_get:palm.balsam.v1.UserSignInByEmail.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserSignInByEmail::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.balsam.v1.UserSignInByEmail.password)
}
inline std::string* UserSignInByEmail::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:palm.balsam.v1.UserSignInByEmail.password)
  return _s;
}
inline const std::string& UserSignInByEmail::_internal_password() const {
  return _impl_.password_.Get();
}
inline void UserSignInByEmail::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSignInByEmail::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* UserSignInByEmail::release_password() {
  // @@protoc_insertion_point(field_release:palm.balsam.v1.UserSignInByEmail.password)
  return _impl_.password_.Release();
}
inline void UserSignInByEmail::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.balsam.v1.UserSignInByEmail.password)
}

// .google.protobuf.Duration ttl = 9;
inline bool UserSignInByEmail::_internal_has_ttl() const {
  return this != internal_default_instance() && _impl_.ttl_ != nullptr;
}
inline bool UserSignInByEmail::has_ttl() const {
  return _internal_has_ttl();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& UserSignInByEmail::_internal_ttl() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.ttl_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& UserSignInByEmail::ttl() const {
  // @@protoc_insertion_point(field_get:palm.balsam.v1.UserSignInByEmail.ttl)
  return _internal_ttl();
}
inline void UserSignInByEmail::unsafe_arena_set_allocated_ttl(
    ::PROTOBUF_NAMESPACE_ID::Duration* ttl) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ttl_);
  }
  _impl_.ttl_ = ttl;
  if (ttl) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.balsam.v1.UserSignInByEmail.ttl)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* UserSignInByEmail::release_ttl() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.ttl_;
  _impl_.ttl_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* UserSignInByEmail::unsafe_arena_release_ttl() {
  // @@protoc_insertion_point(field_release:palm.balsam.v1.UserSignInByEmail.ttl)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.ttl_;
  _impl_.ttl_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* UserSignInByEmail::_internal_mutable_ttl() {
  
  if (_impl_.ttl_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.ttl_ = p;
  }
  return _impl_.ttl_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* UserSignInByEmail::mutable_ttl() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_ttl();
  // @@protoc_insertion_point(field_mutable:palm.balsam.v1.UserSignInByEmail.ttl)
  return _msg;
}
inline void UserSignInByEmail::set_allocated_ttl(::PROTOBUF_NAMESPACE_ID::Duration* ttl) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ttl_);
  }
  if (ttl) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ttl));
    if (message_arena != submessage_arena) {
      ttl = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ttl, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ttl_ = ttl;
  // @@protoc_insertion_point(field_set_allocated:palm.balsam.v1.UserSignInByEmail.ttl)
}

inline bool UserSignInByEmail::has_user() const {
  return user_case() != USER_NOT_SET;
}
inline void UserSignInByEmail::clear_has_user() {
  _impl_._oneof_case_[0] = USER_NOT_SET;
}
inline UserSignInByEmail::UserCase UserSignInByEmail::user_case() const {
  return UserSignInByEmail::UserCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// UserSignInResponse

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace balsam
}  // namespace palm

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_balsam_2eproto
